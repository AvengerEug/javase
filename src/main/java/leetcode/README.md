# Leetcode之旅

## 每日打卡leetcode
* 规则: 根据leetcode的每日一题进行打卡

## 导航栏

|           类名           |                         对应算法题目                         | 难度 |  完成时间  |                             总结                             |
| :----------------------: | :----------------------------------------------------------: | :--: | :--------: | :----------------------------------------------------------: |
| MergeTwoSortedLists.java | [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists) | 简单 | 2020/05.01 | 1. 一开始的思想居然是把两个链表合并成一个链表，然后对他迭代排序，到最后因为对象引用的处理不当，一直卡壳。最后直接看了官方的答案。<br>2.看了官方的答案后知道了有递归和迭代的两种方式实现。针对递归，一开始看的是云里雾里的，最后自己在笔记本上用笔画出了每个调用过程以及结合了递归的基本思想(`递规的基本思想是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解`)进行了理解，也算是基本理解了。<br>3.通过迭代的方式，这和自己一开始的思想是一样的。只不过自己画蛇添足了。看了官方的迭代方式的答案后，一直有一个问题困扰着自己，就是preNode节点一开始的引用是指向哑结点preHead的，但是后续它明明修改了引用，那为什么还能操作到preHead呢？后来才发现是自己基础不足，把链表当成一个list对象了，以为整个链表都是一个对象。但是实际上每个链表都是由一个个节点组成的，每个节点就只有那么几个属性: **val、next**，其中next存储的下一个节点的引用。preNode一开始操作的是preHead节点后续都是操作preHead的next节点以及preHead的next节点的next节点。 |
| LengthOfLongestSubstring | [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters) | 中等 | 2020/05/02 | 1. 自己的思路：将字符串转成数组，针对每个字符查找出它的`无重复字符的子串`，并使用一个变量用来记录`无重复字符子串的最大长度`。此方法应该是比较常规的思路了。缺点是效率比较低。基本上时间复杂度为O(m * (m -1))，m为字符串的长度<br>2. 官网推荐的`滑动窗口`解法，可以说是一个模板吧，以后这种解决**无重复字符的子串**都可以使用此种方法进行解题。大致思路为：遍历字符串的每个字符，获取每个字符对应的`无重复字符的子串`作为一个`滑动窗口`，但是这里和上面的解法有个区别。因为滑动窗口中的字符串已经是一个**无重复字符的子串**了，所以后续的操作都是对`滑动窗口`而言，因为`滑动窗口`的第一个元素就是遍历字符串数组的当前字符，当进行下一轮遍历时，要把滑动窗口的第一个字符给去掉，以及获取`滑动窗口`的最后一个字符的index，然后再从字符串的index + 1的位置上开始处理字符，若字符不在`滑动窗口`中,那么此字符应该加入到`滑动窗口`中, 作为当前处理字符的**无重复字符子串**的一个元素。同时也要定义一个变量存储**无重复字符的子串**的最大长度，每次产生新的**无重复字符的子串**时，再去长度最大的那个。 |
|                          |                                                              |      |            |                                                              |

