

## IO模型

* IO模型就是说用什么样的通道进行数据的发送和接收。Java共支持3中网络编程模式：BIO，NIO，AIO

### 一、BIO（Blocking IO）

* 同步阻塞模型，一个客户端连接对应一个处理线程

* 缺点：

  1. IO代码里read操作是阻塞操作，如果客户端不做写数据，会导致线程阻塞，浪费服务器资源
  2. （使用多线程的方式保证为每一个连接的客户端开启一个线程）如果线程很多，并且执行业务逻辑耗时非常长，最终会导致服务器的资源耗尽。像在linux系统下，句柄的大小是有限制的，当超过句柄限制后，会直接丢弃请求。

* 应用场景：

  BIO方式适用于连接数目比较小且比较固定的架构，这种方式对服务器资源要求比较高，但程序简单易理解。

* BIO缺点重现方案：

  ```txt
  重现上一个线程无法处理完逻辑导致后面的线程无法连接服务器
  1、在单线程BIO中，因上一个连接的客户端一直没有写数据，导致服务器卡在read方法处，此时我们来开启一个新客户端进行连接，会发现，新客户端无法连接服务器。
  
  重现BIO多线程模型中，一个客户端对应一个线程处理，导致服务器资源耗尽
  2、在服务端中，针对每一个连接的客户端都开启一个新线程去处理，达到一个客户端对应一个线程处理。若每一个线程处理的业务逻辑耗时非常长，而此时连接服务器的客户端又非常的多。此时就会一直不停的创建新线程，抛开创建新线程的要调用native方法的耗时不说，最终都会一直创建线程，导致服务器资源耗尽。
  ==> 当然，可以使用线程池来代替，但是使用线程池的话，我们线程池处理线程的能力是有限的，使用线程池的原因是避免每次创建线程而带来的上下文切换的损耗。
  
  ```

### 二、NIO（No Blocking IO）

* 同步非阻塞模型（**单线程情况下在accept和read方法非阻塞**），服务器实现的模式为：**一个线程可以处理多个请求（连接）**，`看到这句话，再回想下，BIO是否能一个线程处理多个连接？`。客户端发送的连接请求都会注册到多路复用器selector上，多路复用器轮训到连接有IO请求就进行处理。

  IO多路复用底层一般用的Linux API（select，poll，epoll）来实现，他们的区别如下表：

  |          |                 select                 |                  poll                  |                    epoll（jdk 1.5及以上）                    |
  | :------- | :------------------------------------: | :------------------------------------: | :----------------------------------------------------------: |
  | 操作方式 |                  遍历                  |                  遍历                  |                             回调                             |
  | 底层实现 |                  数组                  |                  链表                  |                            哈希表                            |
  | IO效率   | 每次调用都进行线性遍历，时间复杂度O(n) | 每次调用都进行线性遍历，时间复杂度O(n) | 事件通知方式，每当有IO事件就绪，系统注册的回调函数就会被调用，时间复杂度O(1) |
  |          |                 有上限                 |                 无上限                 |                            无上限                            |

* 应用场景：

  NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯。编程比较复杂，JDK1.4开始支持。

