## Reactor 之 主从线程模型
* 多线程（**服务器多线程**）模型中，一共分主、从两种线程。主线程主要是处理连接事件，将注册到服务器的channel注册到从线程的selector中去。而从线程主要处理读事件，其中这里的从线程并不是指一个线程，而是来指定多个线程。：

  > 1、主线程接收客户端的链接  ----- 主线程完成，并将连接到服务器的channel注册到从线程的selector中
  >
  > 2、从线程读取已连接上的客户端发来的数据
  >
  > 2.1、从线程读取已连接上的客户端发来的数据
  >
  > 2.2、读到数据后要解码  ----- 异步（将channel的数据读取到buffer中，最终转成一个字符串）
  >
  > 2.3、处理业务逻辑  ----- 异步
  >
  > 2.4、编码  -----  异步（将字符串）
  >
  > 2.5、响应客户端（将要给客户端响应数据的字符串解码成一个byte数组）
  
* 实现细节：主线程主要处理连接事件，内部维护一系列的selector以及对应的线程池，每一次有客户端连接到服务器时，轮询的将channel注册到对应的selector中，具体读取数据的逻辑在对应的selector中去处理。其中，selector处理读取事件的逻辑和多线程的模型一样。因此，主从模型的主要区别就是：**各司其职**，主线程专门处理连接事件，并将连接到服务器的客户端注册到对应的selector中去，而从线程则是专心的处理客户端发送给服务器的请求。

## 遇到的问题（详见masterslavereactorproblem包下的代码）
1. 线程a在select方法中阻塞，线程b调用register方法，注册到selector中，两者会产生死锁。因为线程a在select过程中占用了一个叫**publicKey**的锁，线程b在register方法时也会去占用这把锁，而线程a一直没有释放这把锁，因此造成了线程b一直阻塞在那里
2. 在AcceptAction的run方法改成同步方法 以及 在注册事件前执行wakeUp方法后，就能正常解阻塞了（待查明原因）。
3. 当客户端发送消息时，服务端在无限执行
4. 当ReadAndWriteAction的run方法单纯的打印一句话时，会变成死循环

## 解决问题

* Q1：线程a在select方法中阻塞，线程b调用register方法，两者会产生死锁。因为线程a在select过程中占用了一个叫**publicKey**的锁，线程b在register方法时也会去占用这把锁，而线程a一直没有释放这把锁，因此造成了线程b一直阻塞在那里

* A1：有时能重现，有时候不能重现，总而言之就是避免多个线程操作同一个selector

  ----

* Q2：在AcceptAction的run方法改成同步方法 以及 在注册事件前执行wakeUp方法后，就能正常解阻塞了

* A2：改成同步方法的主要原因是防止**num**变量的操作出现并发的问题，保证每一个连接到服务器的客户端能正常的注册到SlaveReactor中的selector中。在注册时间前执行wakeUp方法主要的原因是解除select的阻塞，若不执行wakeUp方法的话，在执行后面的register方法会和select方法的阻塞造成**死锁**。因此，最好在注册新事件前先执行一遍wakeUp方法，防止和后面的register方法**死锁**。但wakeUp方法最终的底层实现就是**解除select的阻塞**。

  ---

* Q3：当客户端发送消息时，服务端在无限执行

* A3：此现象的主要原因是因为我使用我在处理读事件时没有对channel中的数据进行读取，当处理完读事件后（并没有处理channel中的数据）**selector发现channel中还有数据，则认为读事件还没有完成**，因此select方法还不会阻塞，这也就是一直出现死循环的原因。但是当我使用线程池处理的时候，却发现不会死循环，但会出现多个线程同时执行读事件里面的逻辑，这是因为使用多线程在处理同一个channel导致的并发问题。最终的解决方案就是，读数据和写数据在单线程中处理，当处理到业务逻辑时，才使用异步处理，保证不会出现多个线程操作同一个channel的数据。

  ---

* Q4：当ReadAndWriteAction的run方法单纯的打印一句话时，会变成死循环

* A4：问题答案同**Q3**

