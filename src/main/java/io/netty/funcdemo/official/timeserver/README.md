## 编写一个时间协议的网络程序

* 在时间协议的网络应用程序中，它将具备：**在不接收到任何请求时，都会响应一个32位长度的int类型的数字并关闭连接**的功能。

* 在这个应用程序中，你将学到：

  - [x] 如何构造并发送数据

  - [x] 如何完成的关闭连接
  
## 为什么会出现数据包碎片化？
* 所谓碎片化的情况：

  ```txt
  假设服务端向客户端发送了大量数据，分别发送了3个数据包，分别为: ABC DEF GHI
  
  但是由于基于流传输的传输协议，比如TCP/IP。它们接收的数据都是存在socket的缓冲区当中的，不幸的是，这个缓冲区不是基于数据包的队列，而是基于字节流的队列。
  那刚刚举的例子来说：服务端向客户端发送了大量数据，发了三个数据包。经过了TCP/IP协议的传输后，客户端拿到的数据可能为：AB CDEFG H I 四个数据包
  
  ```

### 解决方案一(version2包下的代码)

* 特殊业务场景做特殊定制：针对time protocol协议创建一个缓冲区，因为我们知道服务端发来消息时，一般是只有4个字节，那我们就创建一个4个字节的缓冲区，每次读取时就往缓冲区里面塞，当缓冲区数据满了之后，则表示要处理业务逻辑了。

### 解决方案二(version3包下的代码)

* 针对传输数据是可变的协议的情况下，我们应该多个channelHandler来处理，一个channelHandler来处理数据包碎片化的问题，另外一个channelHandler来处理业务逻辑。

### 使用pojo传输实现time protocol协议(version4包下的代码)

* 首先，我们来总结下整个time protocol的交互pojo的流程。

  > 1、启动服务端
  >
  > 2、客户端连接服务端
  >
  > 3、服务端将当前服务端的时间以**UnixTime**的pojo格式发送给客户端，但实际上并不是将整个pojo对象进行发送，而是仅仅将内部的value字段的值做了网络传输，然后在客户端针对这个值再重新创建出来了一个对象。

* 虽然流程比较简单，但是我们要注意TimeEncoder和TimeDecoder的时机。 TimeEncoder是Time的一个编码器，顾名思义，就是我要准备进行网络传输数据时才会使用到这个TimeEncoder，因此我们需要为服务端添加这个编码器。反之，服务端是对Time进行了编码，那么客户端肯定就是进行解码了，因此，要为客户端添加TimeDecoder解码器。