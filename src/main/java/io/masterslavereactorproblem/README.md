## Reactor 之 主从线程模型
* 多线程（**服务器多线程**）模型中，一共分主、从两种线程。主线程主要是处理连接事件，将注册到服务器的channel注册到从线程的selector中去。而从线程主要处理读事件，其中这里的从线程并不是指一个线程，而是来指定多个线程。：

  > 1、主线程接收客户端的链接  ----- 主线程完成，并将连接到服务器的channel注册到从线程的selector中
  >
  > 2、从线程读取已连接上的客户端发来的数据
  >
  > 2.1、从线程读取已连接上的客户端发来的数据
  >
  > 2.2、读到数据后要解码  ----- 异步（将channel的数据读取到buffer中，最终转成一个字符串）
  >
  > 2.3、处理业务逻辑  ----- 异步
  >
  > 2.4、编码  -----  异步（将字符串）
  >
  > 2.5、响应客户端（将要给客户端响应数据的字符串解码成一个byte数组）
  
* 实现细节：主线程主要处理连接事件，内部维护一系列的selector以及对应的线程池，每一次有客户端连接到服务器时，轮询的将channel注册到对应的selector中，具体读取数据的逻辑在对应的selector中去处理。其中，selector处理读取事件的逻辑和多线程的模型一样。因此，主从模型的主要区别就是：**各司其职**，主线程专门处理连接事件，并将连接到服务器的客户端注册到对应的selector中去，而从线程则是专心的处理客户端发送给服务器的请求。

## 遇到的问题
1. Q1：线程a在select方法中阻塞，线程b调用register方法，两者会产生死锁。因为线程a在select过程中占用了一个叫**publicKey**的锁，线程b在register方法时也会去占用这把锁，而线程a一直没有释放这把锁，因此造成了线程b一直阻塞在那里。
2. Q2：在AcceptAction的run方法改成同步方法 以及 在注册事件前执行wakeUp方法后，就能正常解阻塞了 。
3. Q3：当客户端发送消息时，服务端在无限执行
4. Q4：当ReadAndWriteAction的run方法单纯的打印一句话时，会变成死循环

## 对应的解决方案

1. Q1：**在register之前调用selector的wakeUp方法。wakeUp方法底层就是把锁给释放了，**
2. Q2：**执行wakeUp的方法原因同上。同时把run方法改成同步方法的话，保证了只有一个线程能执行wakeUp防止了并发问题**
3. Q3：**服务端发送消息时，slaveSelector在处理时是以异步的方式操作的，包括编解码步骤，这样做会出现很奇怪的并发问题，这里的编解码应该同步处理，只有业务逻辑的处理时才使用异步处理。**
4. 