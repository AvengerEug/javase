# java并发编程

## 一、java线程与操作系统(centos 7 64位，以下简称centos)的关系

### 1.1 centos os中创建线程的api

* 在centos中，要创建一个线程最终会调用到`pthread_create`方法。于是，我们执行如下命令来查看此方法内容

  ```shell
  #1. 安装man命令 => 为了查看函数信息
  yum install man-pages
  
  #2. 执行如下命令查看具体内容, 具体内容查看下图
  man pthread_create
  ```

  ![pthread_create](pthread_create.png)

### 1.2 使用os的api(pthread_create)创建一个线程

* 撰写myThread.c文件

  ```c
  #include "pthread.h" //头文件，在pthread_create方法中有明确写到
  #include "stdio.h"
  
  pthread_t pid; // 定义一个变量，用来存储生成的线程id, 在pthread_create方法中也有介绍
  
  /**
   * 定义主体函数
   */
  void* run(void* arg) {
      while(1) {
         printf("\n Execting run function \n");
         printf(arg);
         sleep(1);
      }
  }
  
  /**
   *  若要编译成可执行文件，则需要写main方法
   */
  int main() {
      pthread_create(&pid, NULL, run, "123"); // 调用os创建线程api
      while(1) { // 这里必须要写个死循环，因为c程序在main方法执行结束后，它内部开的子线程也会关掉
      }
  }
  ```

* 编译c文件成可执行命令

  ```shell
  # -pthread参数表示把pthread类库也添加到编译范围
  gcc -o myThread myThread.c -pthread
  ```

* 运行编译后的c文件

  ```shell
  ./myThread
  ```

* 执行结束后可以发现线程每隔1s就打印`Execting run function` 并输出123

  ![pthread_create_run_result](pthread_create_run_result.png)

  

  那我们要怎么去证明这个是**线程**还是**进程**呢？见下图

  ![find_thread.png](find_thread.png)

### 1.3 java中的线程和pthread_create有什么关系？

* 我们可以查看java中**Thread**类的`start`方法

  ```java
  public synchronized void start() {
      // ....... 省略前半部分
      boolean started = false;
      try {
          // *********调用了start0方法*******
          start0();
          started = true;
      } finally {
          // 省略finally中的代码块
      }
  }
  ```

* 我们继续查看`start0`方法

  ```java
  // 它仅仅是一个native修饰的方法，根据我们对jvm的了解，此方法是放在当前线程创建区域中的本地方法栈中
  // 所以它在jvm中肯定有对它的一个实现，但是它是怎么去交互的呢？ 我们目前不知道。。。
  // 按照这样的思路，咱们来创建一个自定义的native方法，然后用java程序去调用
  private native void start0();
  ```

### 1.4 使用java程序调用自己手写的native方法

* 第一步：创建`ExecMyNativeMethod.java`类(不用指定在哪个包下，因为最终要把它放在linux中去执行)

  ```java
  public class ExecMyNativeMethod {
  
      /**
       * 加载本地方法类库，注意这个名字，后面会用到
       */
      static {
          System.loadLibrary("MyNative");
      }
  
      public static void main(String[] args) {
          ExecMyNativeMethod execMyNativeMethod = new ExecMyNativeMethod();
          execMyNativeMethod.start0();
      }
  
      private native void start0();
  }
  ```

* 第二步：将java类编译成class文件

  ```shell
  javac ExecMyNativeMethod.java
  ```

* 第三步：将class文件转成c语言头文件

  ```shell
  javah ExecMyNativeMethod
  ```

* 第四步：我们来大致看一下java文件转成的c语言头文件内容

  ```c
  /* DO NOT EDIT THIS FILE - it is machine generated */
  #include <jni.h>
  /* Header for class ExecMyNativeMethod */
  
  #ifndef _Included_ExecMyNativeMethod
  #define _Included_ExecMyNativeMethod
  #ifdef __cplusplus
  extern "C" {
  #endif
  /*
   * Class:     ExecMyNativeMethod
   * Method:    start0
   * Signature: ()V
   */
  JNIEXPORT void JNICALL Java_ExecMyNativeMethod_start0
    (JNIEnv *, jobject);
  
  #ifdef __cplusplus
  }
  #endif
  #endif
  ```

  对于上述内容，我们只需要关注我们定义的native方法(`JNIEXPORT void JNICALL Java_ExecMyNativeMethod_start0
    (JNIEnv *, jobject);`)即可，也就是说native方法转成c语言头文件后会变成`JNIEXPORT void JNICALL Java_类名_native方法名 (JNIEnv *, jobject);`的格式

* 第五步：更新我们刚刚编写的`myThread.c`文件，为了不造成影响，我们使用cp命令创建出一个新的c文件**myThreadNew.c**

  ```shell
  cp myThread.c myThreadNew.c
  ```

  同时修改**myThreadNew.c**文件为如下内容

  ```c
  #include "pthread.h" // 引用线程的头文件，在pthread_create方法中有明确写到
  #include "stdio.h"
  #include "ExecMyNativeMethod.h" // 将自定义的头文件导入
  
  pthread_t pid; // 定义一个变量，用来存储生成的线程id, 在pthread_create方法中也有介绍
  
  /**
   * 定义主体函数
   */
  void* run(void* arg) {
      while(1) {
         printf("\n Execting run function \n");
         printf(arg);
         sleep(1);
      }
  }
  
  /**
   * 此方法就是后面java要调用到的native方法
   */
  JNIEXPORT void JNICALL Java_ExecMyNativeMethod_start0(JNIEnv *env, jobject c1) {
      pthread_create(&pid, NULL, run, "Creating thread from java application"); // 调用os创建线程api
      while(1) {} // 死循环等待
  }
  
  /**
   * 每个要执行的c文件都要写main方法，
   * 如果要编译成动态链接库，则不需要
   */
  int main() {
      return 0;
  }
  ```

* 第六步：执行如下命令将`myThreadNew.c`文件编译成**动态链接库**，并添加到环境变量中(否则在启动java类的main方法时，在静态代码块中找不到`myNative`类库)

  ```shell
  # 1. 编译成动态链接库
  # 说明下-I后面的参数: 分别指定jdk安装目录的include文件夹和include/linux文件夹
  # 因为我在环境变量中配置了JAVA_HOME，所以我直接世界$JAVA_HOME引用了
  # 后面的libMyNative.so文件，它的格式为lib{xxx}.so
  # 其中{xxx}为类中System.loadLibrary("yyyy")代码中yyyy的值
  gcc -I $JAVA_HOME/include -I $JAVA_HOME/include/linux -fPIC -shared -o libMyNative.so myThreadNew.c
  
  # 2. 将此动态链接库添加到环境变量中
  # 格式: export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:{libxxxx.so}
  # 其中{libxxxxNative.so}为动态链接库的路径, 
  # 我的libMyNative.so文件在/root/workspace文件夹下
  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/workspace/libMyNative.so
  ```

* 第七步：执行如下命令启动java程序

  ```shell
  java ExecMyNativeMethod
  ```

  运行结果：

  ![call_customize_native_method.png](call_customize_native_method.png)

  **完美！**我们成功的使用java应用程序调用了我们自定义的native方法。可是，我们在用java创建一个线程时，通常是要自己重写run方法，当我们启动线程时，调用的是start方法。刚刚我们证明了，native方法就是会调用到操作系统的一个c文件，如果要调用到run方法，那么我们就必须要通过c来调用到java中的方法。那我们接下来尝试着使用c文件来调用java代码

### 1.5 c语言文件调用java代码

* 第一步：优化我们的`ExecMyNativeMethod.java`类，新增run方法，具体如下：

  ```java
  package com.eugene.basic.thread.myNative;
  
  public class ExecMyNativeMethod {
  
      /**
       * 加载本地方法类库，注意这个名字，后面会用到
       */
      static {
          System.loadLibrary("MyNative");
      }
  
      public static void main(String[] args) {
          ExecMyNativeMethod execMyNativeMethod = new ExecMyNativeMethod();
          execMyNativeMethod.start0();
      }
  
      private native void start0();
  
      public void run() {
          System.out.println("I'm run method..........");
      }
  }
  ```

* 第二步：修改上述的`myThreadNew.c`文件为如下内容(用到了`JNI`，这个c文件在jdk的安装目录中可以找到，所以这是jdk提供的功能)：

  ```c
  #include "stdio.h"
  #include "ExecMyNativeMethod.h" // 将自定义的头文件导入
  #include "jni.h"
  
  /**
   * 此方法就是后面java要调用到的native方法
   */
  JNIEXPORT void JNICALL Java_ExecMyNativeMethod_start0(JNIEnv *env, jobject c1) {
  	jclass cls = (*env)->FindClass(env, "ExecMyNativeMethod");
      if (cls == NULL) {
          printf("Not found class!");
          return;
      }
      
      jmethodID cid = (*env)->GetMethodID(env, cls, "<init>", "()V");
      if (cid == NULL) {
          printf("Not found constructor!");
          return;
      }
      
      jobject obj = (*env)->NewObject(env, cls, cid);
      if (obj == NULL) {
          printf("Init object failed!");
          return;
  	}
      
      jmethodID rid = (*env)->GetMethodID(env, cls, "run", "()V");
      jint ret = (*env)->CallIntMethod(env, obj, rid, NULL);
  	
      printf("Finished!");
  }
  ```

* 第三步：将`myThreadNew.c`文件编译成`动态链接库`

  ```shell
  gcc -I $JAVA_HOME/include -I $JAVA_HOME/include/linux -fPIC -shared -o libMyNative.so myThreadNew.c
  ```

* 第四步：编译java类并执行它

  ```java
  javac ExecMyNativeMethod.java
  java ExecMyNativeMethod
  ```

* 运行结果：

  ![c_call_java_method.png](c_call_java_method.png)

  **牛逼！**



## 二、线程基础

### 2.1 如何终止一个阻塞状态的线程

* 首先咱们要理解线程处于阻塞状态的情况，在这里只考虑如下两种情况

  ```java
  /**
    情况一：
      run方法内部执行逻辑是使用while + 一个布尔变量来控制逻辑的
      此种方法，我们可以通过修改flag变量来达到终止线程的目的。
      但是这种情况有一种缺陷，就是假如我在循环体内睡眠了10s，然后
      主线程在3s的时候把flag设置为false了。当我们把flag设置为false时，
      其实是想让线程立马终止的，但是按照这样的一个逻辑的话，它并不会立马
      终止，反而会再睡眠7s钟后执行后面的System.out.println("runing");
      代码。
      
      所以我们直接使用flag的方式达不到立即终止线程的阻塞状态
    */
  static flag = true;
  public static void main(String[] args) {
      MyThread t = new MyThread();
      t.start();
  }
  
  private static class MyThread extends Thread {
      public void run() {
          while(flag) {
              try {
                  Thread.sleep(10000);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              System.out.println("runing");   
          }
      }
  }
  
  /**
    情况二：
      我们的目的是直接让线程停止，那我们直接调用它的stop方法不就行了吗？
      如下述main方法所述。
  	
  	emmm, 我想说这样的确能达到目的，但是jvm不推荐这么停止一个线程，
  	而且stop方法在后续的jdk版本中可能会被抛弃。为什么不推荐呢？
  	我们假设这么一个场景，我们要不停的读取一个文件，所以要在while
  	循环体中打开一个文件流，假设还未执行到关闭流的代码部分，主线程
  	就调用到了stop方法，那这不就造成资源浪费了嘛
   */
  public static void main(String[] args) {
  	t.stop();
  }
  ```

  总而言之：jvm不希望直接停止一个线程，而是希望线程要执行结束。那么我们要如何解决上述的情况二呢？我们可以使用`interrupt()`方法，假设一个线程执行此方法时，它会抛出`InterruptedException`异常，此时我们可以截取到这个异常然后执行一些`关闭资源`类似的操作

  